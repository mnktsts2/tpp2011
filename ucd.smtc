; z3 /smtc ucd.smtc

(set-option :produce-models true)
;(set-option :produce-assignments true)

(declare-fun N () Int)
(assert (> N 0))

(define-fun is-nat ((n Int)) Bool (>= n 0))
(define-fun is-even-nat ((n Int)) Bool (and (is-nat n) (= (mod n 2) 0)))
(define-fun is-child ((i Int)) Bool (and (<= 1 i) (<= i N)))

; Let m(i,k) be the number of candies held by the i'th child (i in {1,...,N})
; after k steps. 
(declare-fun m (Int Int) Int)

; Def. max(k) = max{m(i,k) | i in {1,...,N}}
(declare-fun max-child (Int) Int)
(define-fun max ((k Int)) Int (m (max-child k) k))
(assert
  (forall ((k Int))
    (is-child (max-child k))
    :pat { (max-child k) } ))
(assert
  (forall ((k Int) (i Int))
    (=> (is-child i) (>= (max k) (m i k)))
    :pat { (m i k) } ))

; Def. min(k) = min{m(i,k) | i in {1,...,N}}
(declare-fun min-child (Int) Int)
(define-fun min ((k Int)) Int (m (min-child k) k))
(assert
  (forall ((k Int))
    (is-child (min-child k))
    :pat { (min-child k) } ))
(assert
  (forall ((k Int) (i Int))
    (=> (is-child i) (<= (min k) (m i k)))
    :pat { (m i k) } ))

; Def. right(i) = (if (i < N) then (i+1) else 1).
(define-fun right ((i Int)) Int (ite (< i N) (+ i 1) 1))

; (declare-fun right-n (Int Int) Int)
; (assert
;   (forall ((n Int)) (=> (= n 0) (= (right-n i n) i))

; initial state
(assert
  (forall ((i Int) (k Int))
    (=> (and (is-child i) (= k 0)) (is-even-nat (m i k)))
    :pat { (m i k) } ))

; transition relation
(define-fun trans ((i Int) (k Int)) Bool
  (let ((tmp (+ (div (m i k) 2) (div (m (right i) k) 2))))
       (= (m i (+ k 1))
          (ite (is-even-nat tmp) tmp (+ tmp 1)))))

; ; to avoid trigger loop
; (declare-fun m1 (Int Int) Int)
; (assert
;   (forall ((i Int) (k Int))
;     (= (m i k) (m1 i k))
;     :pat { (m i k) }))
; (define-fun trans1 ((i Int) (k Int)) Bool
;   (let ((tmp (+ (div (m1 i k) 2) (div (m1 (right i) k) 2))))
;        (= (m1 i (+ k 1))
;           (ite (is-even-nat tmp) tmp (+ tmp 1)))))
; (assert 
;   (forall ((i Int) (k Int))
;     (=> (and (is-child i) (is-nat k)) (trans1 i k))
; ;    (trans1 i k)
;     :pat { (m i k) } ))

; Def. state invariant
(define-fun state-inv ((k Int)) Bool
  (forall ((i Int))
    (=> (is-child i) (is-even-nat (m i k)))
    :pat { (m i k) } ))
; Lemma. Preservation of state invariant
(push)
(declare-fun k () Int)
(assert (state-inv k))
(declare-fun i () Int)
(assert (is-child i))
(assert (trans i k))
(assert (not (is-even-nat (m i k)))) ; negation of the goal
(check-sat) ; unsat
(pop)
(assert
  (forall ((i Int) (k Int))
    (=> (and (is-child i) (is-nat k)) (is-even-nat (m i k)))
    :pat { (m i k) } ))

;; Experiments
(declare-fun k () Int)
(assert (is-nat k))

; (1) max(k+1) <= max(k)
(push)
(assert (trans (max-child (+ k 1)) k))
(assert (not (<= (max (+ k 1)) (max k)))) ; negation of the goal
(check-sat) ; unsat
(pop)

; (2) min(k) <= min(k+1)
(push)
(assert (trans (min-child (+ k 1)) k))
(assert (not (<= (min k) (min (+ k 1))))) ; negation of the goal
(check-sat) ; unsat
(pop)

; (3) if min(k) < m(i,k) then min(k) < m(i,k+1)
(push)
(declare-fun i () Int)
(assert (is-child i))
(assert (trans i k))
(assert (< (min k) (m i k)))
(assert (not (< (min k) (m i (+ k 1))))) ; negation of the goal
(check-sat) ; unsat
(pop)

; (4) if m(i,k) < m(right(i),k) then m(i,k) < m(i,k+1)
(push)
(declare-fun i () Int)
(assert (is-child i))
(assert (trans i k))
(assert (< (m i k) (m (right i) k)))
(assert (not (< (m i k) (m i (+ k 1))))) ; negation of the goal
(check-sat) ; unsat
(pop)

;  (5) if (min(k) < m(i,k)) for some i,
;      then num(min(k),k+1) < num(min(k),k),
; for each j
;   if min(k) < m(j,k) then min(k) < m(j,k+1) by (3)
;   if min(k) = m(j,k)
;     if min(k) = m(j,k) < m(right(j),k) then min(k) < m(j,k+1) by (4)
;     if not (m(j,k) < m(right(j),k)) then
;       min(k) = m(j,k) = m(right(j),k)
; すべて最後のケースの場合に個数は変わらない。でも、それは前提に矛盾。

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; if (min(k) < m(i,k)) for some i, then min(k)=m(j,k)<m(j,k+1) for some j.
(push)
(declare-fun i () Int)
(assert (is-child i))
(assert (< (min k) (m i k)))
(assert (forall ((j Int)) (trans j k) :pat { (m j k) } ))
(assert
  (forall ((j Int))
    (=> (= (min k) (m j k)) (= (min k) (m j (+ k 1))))
    :pat { (m j k) } )) ; negation of the goal

(define-fun P ((j Int)) Bool (= (min k) (m j k)))
; base case: P(min-child(k))
(push)
(assert (not (P (min-child k))))
(check-sat) ; unsat
(pop)
; inductive step: P(j) -> P(right(j))
(push)
(declare-fun j () Int)
(assert (is-child j))
(assert (P j))
(assert (trans j k))
(assert (not (P (right j))))
(check-sat) ; unsat
(pop)
; conclusion of induction
(assert (forall ((j Int)) (=> (is-child j)  (P j)) :pat { (m j k) } ))

(check-sat) ; unsat
(pop)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof outline:
; Let m(i,k) be the number of candies held by the i'th
; child (i in {1,...,N}) after k steps. At first, prove the following
; lemmas:
; 
;  (1) max(k+1) <= max(k),
;  (2) min(k) <= min(k+1),
;  (3) if min(k) < m(i,k) then min(k) < m(i,k+1),
;  (4) if m(i,k) < m(right(i),k) then m(i,k) < m(i,k+1),
; 
; where
; 
;     max(k) = max{m(i,k) | i in {1,...,N}},
;     min(k) = min{m(i,k) | i in {1,...,N}},
;   right(i) = (if (i < N) then (i+1) else 1).
; 
; Then, prove the following lemma:
; 
;  (5) if (min(k) < m(i,k)) for some i,
;      then num(min(k),k+1) < num(min(k),k),
; 
; where
; 
;   num(m,k) is the number of children holding m candies after k steps.
; 
; Finally, it can be proven that all the children eventually hold the
; same number of candies.
