; z3 /smtc ucd.smtc

(set-option :produce-models true)
;(set-option :produce-assignments true)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(declare-fun N () Int)
(assert (> N 0))

(define-fun is-nat ((n Int)) Bool (>= n 0))
(define-fun is-even-nat ((n Int)) Bool (and (is-nat n) (= (mod n 2) 0)))
(define-fun is-child ((i Int)) Bool (and (<= 1 i) (<= i N)))

; Let m(i,k) be the number of candies held by the i'th child (i in {1,...,N})
; after k steps. 
(declare-fun m (Int Int) Int)

; Def. max(k) = max{m(i,k) | i in {1,...,N}}
(declare-fun max-child (Int) Int)
(define-fun max ((k Int)) Int (m (max-child k) k))
(assert
  (forall ((k Int))
    (is-child (max-child k))
    :pat { (max-child k) } ))
(assert
  (forall ((k Int) (i Int))
    (=> (is-child i) (>= (max k) (m i k)))
    :pat { (m i k) } ))

; Def. min(k) = min{m(i,k) | i in {1,...,N}}
(declare-fun min-child (Int) Int)
(define-fun min ((k Int)) Int (m (min-child k) k))
(assert
  (forall ((k Int))
    (is-child (min-child k))
    :pat { (min-child k) } ))
(assert
  (forall ((k Int) (i Int))
    (=> (is-child i) (<= (min k) (m i k)))
    :pat { (m i k) } ))

; Def. right(i) = (if (i < N) then (i+1) else 1).
(define-fun right ((i Int)) Int (ite (< i N) (+ i 1) 1))

; Def. num(n,k) is the number of children holding m candies after k steps.
; Note that the axiomatization is partial.
(declare-fun num (Int Int) Int)
(assert (forall ((n Int) (k Int)) (is-nat (num n k)) :pat { (num n k) }))
(assert
  (forall ((n Int) (k Int))
    (=>
      (exists ((i Int)) (and (is-child i) (= (m i k) n) (not (= (m i (+ k 1)) n))))
      (forall ((i Int)) (=> (is-child i) (not (= (m i k) n)) (not (= (m i (+ k 1)) n))))
      (< (num n (+ k 1)) (num n k)))
    :pat { (num n k) } ))

; initial state
(assert
  (forall ((i Int) (k Int))
    (=> (is-child i) (= k 0) (is-even-nat (m i k)))
    :pat { (m i k) } ))

; transition relation
(define-fun trans ((i Int) (k Int)) Bool
  (let ((tmp (+ (div (m i k) 2) (div (m (right i) k) 2))))
       (= (m i (+ k 1))
          (ite (is-even-nat tmp) tmp (+ tmp 1)))))

; ; to avoid trigger loop
; (declare-fun m1 (Int Int) Int)
; (assert
;   (forall ((i Int) (k Int))
;     (= (m i k) (m1 i k))
;     :pat { (m i k) }))
; (define-fun trans1 ((i Int) (k Int)) Bool
;   (let ((tmp (+ (div (m1 i k) 2) (div (m1 (right i) k) 2))))
;        (= (m1 i (+ k 1))
;           (ite (is-even-nat tmp) tmp (+ tmp 1)))))
; (assert 
;   (forall ((i Int) (k Int))
;     (=> (is-child i) (is-nat k) (trans1 i k))
; ;    (trans1 i k)
;     :pat { (m i k) } ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Def. state invariant
(define-fun state-inv ((k Int)) Bool
  (forall ((i Int))
    (=> (is-child i) (is-even-nat (m i k)))
    :pat { (m i k) } ))
; Lemma. Preservation of state invariant
; base case: state-inv(0)
(push)
  (assert (not (state-inv 0))) ; negation of the goal
  (check-sat) ; unsat
(pop)
; induction step: state-inv(k) → state-inv(k+1)
(push)
  (declare-fun k1 () Int)
  (define-fun k () Int (- k1 1))
  (assert (is-nat k))
  (assert (forall ((i Int)) (=> (is-child i) (trans i k)) :pat { (m i k1) } ))
  (assert (state-inv k)) ; induction hypothesis
  (assert (not (state-inv k1))) ; negation of the goal
  (check-sat) ; unsat
(pop)
; conclusion of induction
; 
; Note:
; - Is justification of the induction scheme necessary?
; - state-inv is not reused since we want to use (m i k) as a trigger.
; - is-nat should not be used as a trigger since it is interpreted function.
(assert
  (forall ((i Int) (k Int))
    (=> (is-child i) (is-nat k) (is-even-nat (m i k)))
    :pat { (m i k) } ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; loop variant
(define-fun loop-variant-1 ((k Int)) Int (- (max k) (min k)))
(define-fun loop-variant-2 ((k Int)) Int (num (min k) k))

; lexicographical ordering
(declare-fun lt (Int Int Int Int) Bool)
(assert
  (forall ((a1 Int) (a2 Int) (b1 Int) (b2 Int))
    (= (lt a1 a2 b1 b2)
       (and (is-nat a1) (is-nat a2)
            (or (< a1 b1)
                (and (= a1 b1) (< a2 b2)))))))

(define-fun loop-variant-decrease ((k Int)) Bool
  (lt (loop-variant-1 (+ k 1)) (loop-variant-2 (+ k 1))
      (loop-variant-1 k) (loop-variant-2 k)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(push)
  (declare-fun k () Int)
  (assert (is-nat k))
  (assert (forall ((j Int)) (=> (is-child j) (trans j k)) :pat { (m j (+ k 1)) } )) ; Is it a fragile trigger?

  ; (1) max(k+1) <= max(k)
  (push)
    (assert (not (<= (max (+ k 1)) (max k)))) ; negation of the goal
    (check-sat) ; unsat
  (pop)

  ; (2) min(k) <= min(k+1)
  (push)
    (assert (not (<= (min k) (min (+ k 1))))) ; negation of the goal
    (check-sat) ; unsat
  (pop)

  ; (3) if min(k) < m(i,k) then min(k) < m(i,k+1)
  (push)
    (declare-fun i () Int)
    (assert (is-child i))
    (assert (< (min k) (m i k)))
    (assert (not (< (min k) (m i (+ k 1))))) ; negation of the goal
    (check-sat) ; unsat
  (pop)

  ; (4) if m(i,k) < m(right(i),k) then m(i,k) < m(i,k+1)
  (push)
    (declare-fun i () Int)
    (assert (is-child i))
    (assert (< (m i k) (m (right i) k)))
    (assert (not (< (m i k) (m i (+ k 1))))) ; negation of the goal
    (check-sat) ; unsat
  (pop)

  ; (5) if (min(k) < m(i,k)) for some i,
  ;     then num(min(k),k+1) < num(min(k),k),
  (push)
    ; Suppose (min(k) < m(i,k)) for some i.
    (declare-fun i () Int)
    (assert (is-child i))
    (assert (< (min k) (m i k)))

    ; Show m(j,k)=min(k) and min(k)<(j,k+1) for some j.
    (push)
      (assert
        (forall ((j Int))
          (=> (is-child j) (= (min k) (m j k)) (not (< (min k) (m j (+ k 1)))))
          :pat { (m j k) } )) ; negation of the goal

      (define-fun P ((j Int)) Bool (= (min k) (m j k)))
      ; base case: P(min-child(k))
      (push)
        (assert (not (P (min-child k)))) ; negation of the goal
        (check-sat) ; unsat
      (pop)
      ; induction step: P(j) → P(right(j))
      (push)
        (declare-fun j () Int)
        (assert (is-child j))
        (assert (P j)) ; induction hypothesis
        (assert (not (P (right j)))) ; negation of the goal
        (check-sat) ; unsat
      (pop)
      ; conclusion of induction
      ;
      ; Note:
      ; - Is justification of the induction scheme necessary?
      (assert (forall ((j Int)) (=> (is-child j)  (P j)) :pat { (m j k) } ))

      (check-sat) ; unsat
    (pop)
    (assert
      (exists ((j Int))
        (and (is-child j)
             (= (min k) (m j k))
             (< (min k) (m j (+ k 1))))))

    ; (num(min(k), k+1) < num(min(k), k)) holds.
    (push)
      (assert (not (< (num (min k) (+ k 1)) (num (min k) k)))) ; negation of the goal
      (check-sat) ; unsat
    (pop)

    ; Show that loop variant decrease in lexicographical ordering.
    (push)
      (assert (not (loop-variant-decrease k))) ; negation of the goal
      (check-sat) ; unsat
    (pop)
  (pop)

(pop)

(assert
  (forall ((k Int))
    (=> (is-nat k)
        (exists ((i Int)) (< (min k) (m i k)) :pat { (m i k) })
        (loop-variant-decrease k))
    :pat { (min k) } ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(declare-fun P (Int Int) Bool)
(assert
  (forall ((lv1 Int) (lv2 Int))
    (= (P lv1 lv2)
       (forall ((k Int))
         (=> (is-nat k)
             (= lv1 (loop-variant-1 k))
             (= lv2 (loop-variant-2 k))
             (exists ((k1 Int))
               (and (is-nat k1) (= (min k1) (max k1)))
               :pat { (min k1) }))
         :pat { (min k) }))
    :pat { (P lv1 lv2) }))

; Prove (∀v1,v2. P(v1,v2)) using well-founded induction on lt.
(push)
  (declare-fun v1 () Int)
  (declare-fun v2 () Int)
  (assert (is-nat v1))
  (assert (is-nat v2))

  ; induction hypothesis
  (assert 
    (forall ((u1 Int) (u2 Int))
      (=> (lt u1 u2 v1 v2) (P u1 u2))
      :pat { (lt u1 u2 v1 v2) }))

  ; negation of the goal
  (assert (not (P v1 v2)))

  (check-sat)
(pop)
(assert (forall ((v1 Int) (v2 Int)) (P v1 v2)))

(push)
  (assert (not (P (loop-variant-1 0) (loop-variant-2 0))))
  (check-sat)
(pop)
(assert (P (loop-variant-1 0) (loop-variant-2 0)))

(push)
  (assert (not (exists ((k1 Int)) (and (is-nat k1) (= (min k1) (max k1))))))
  (check-sat)
(pop)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof outline:
; Let m(i,k) be the number of candies held by the i'th
; child (i in {1,...,N}) after k steps. At first, prove the following
; lemmas:
; 
;  (1) max(k+1) <= max(k),
;  (2) min(k) <= min(k+1),
;  (3) if min(k) < m(i,k) then min(k) < m(i,k+1),
;  (4) if m(i,k) < m(right(i),k) then m(i,k) < m(i,k+1),
; 
; where
; 
;     max(k) = max{m(i,k) | i in {1,...,N}},
;     min(k) = min{m(i,k) | i in {1,...,N}},
;   right(i) = (if (i < N) then (i+1) else 1).
; 
; Then, prove the following lemma:
; 
;  (5) if (min(k) < m(i,k)) for some i,
;      then num(min(k),k+1) < num(min(k),k),
; 
; where
; 
;   num(m,k) is the number of children holding m candies after k steps.
; 
; Finally, it can be proven that all the children eventually hold the
; same number of candies.
